# 1. 每日必需要默写的算法

1. 对一个对象进行深clone?

    ```javascript
    function cloneObject(o) {
        if(!o || 'object' !== typeof o) {
            return o;
        }
        var c = 'function' === typeof o.pop ? [] : {};
        var p, v;
        for(p in o) {
            if(o.hasOwnProperty(p)) {
                v = o[p];
                if(v && 'object' === typeof v) {
                    c[p] = Ext.ux.clone(v);
                }
                else {
                    c[p] = v;
                }
            }
        }
        return c;
    };
    ```

1. 冒泡排序

    ```javascript
    function bubbleSort_2(arr) {
        var l = arr.length,
            pos = 0;
        for (var i = 0; i < l; i++) {
            for (var j = 0; j < l - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    pos = j;
                    var temp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }
            l = pos;
        }
        return arr;
    }
    ```

1. 快速排序

    ```javascript
    function quickSort(arr) {
        var l = arr.length;
        if (l <= 1) {
            return arr;
        }
        var pos = Math.floor(arr.length / 2),
            posNum = arr.splice(pos, 1)[0],
            left = [],
            right = [];
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] < posNum) {
                left.push(arr[i])
            } else {
                right.push(arr[i])
            }
        }
        return quickSort(left).concat([posNum], quickSort(right));
    }
    ```

1. 保存状态

    ```javascript
    // 自执行创建模块
    (function() {
        // states 结构预览
        // states = {
        //     a: 1,
        //     b: 2,
        //     m: 30,
        //     o: {}
        // }
        var states = {};  // 私有变量，用来存储状态与数据

        // 判断数据类型
        function type(elem) {
            if(elem == null) {
                return elem + '';
            }
            return toString.call(elem).replace(/[\[\]]/g, '').split(' ')[1].toLowerCase();
        }


        /**
        * @Param name 属性名
        * @Description 通过属性名获取保存在states中的值
        */
        function get(name) {
            return states[name] ? states[name] : '';
        }

        function getStates() {
            return states;
        }

        /*
        * @param options {object} 键值对
        * @param target {object} 属性值为对象的属性，只在函数实现时递归中传入
        * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似
        */
        function set(options, target) {
            var keys = Object.keys(options);
            var o = target ? target : states;

            keys.map(function(item) {
                if(typeof o[item] == 'undefined') {
                    o[item] = options[item];
                }
                else {
                    type(o[item]) == 'object' ? set(options[item], o[item]) : o[item] = options[item];
                }
                return item;
            })
        }

        // 对外提供接口
        window.get = get;
        window.set = set;
        window.getStates = getStates;
    })()

    // 具体使用如下

    set({ a: 20 });     // 保存 属性a
    set({ b: 100 });    // 保存属性b
    set({ c: 10 });     // 保存属性c

    // 保存属性o, 它的值为一个对象
    set({ 
        o: {
            m: 10,
            n: 20
        }
    })

    // 修改对象o 的m值
    set({
        o: {
            m: 1000
        }
    })

    // 给对象o中增加一个c属性
    set({
        o: {
            c: 100
        }
    })
    console.log(getStates())
    ```

1. 柯里化

    ```javascript
    function add() {
        // 第一次执行时，定义一个数组专门用来存储所有的参数
        var _args = [].slice.call(arguments);

        // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
        var adder = function () {
            var _adder = function() {
                [].push.apply(_args, [].slice.call(arguments));
                return _adder;
            };

            // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
            _adder.toString = function () {
                return _args.reduce(function (a, b) {
                    return a + b;
                });
            }

            return _adder;
        }
        return adder.apply(null, [].slice.call(arguments));
    }

    // 输出结果，可自由组合的参数
    console.log(add(1, 2, 3, 4, 5));  // 15
    console.log(add(1, 2, 3, 4)(5));  // 15
    console.log(add(1)(2)(3)(4)(5));  // 15
    ```

1. 手写jsonp代码

    ```javascript
    (function (window, document) {
        'use strict';
        var jsonp = function (url, data, callback) {

            //1 挂载回调函数
            var fnSuffix = Math.random().toString().replace('.', '');
            var cbFuncName = 'my_json_cb_' + fnSuffix;
            //将函数挂载在全局环境的方式不推荐  使用cbs.my_json_cb_
            window[cbFuncName] = callback;

            //2 将data转化成url字符串的形式
            // {id:1,name:'zhangsan'} =>id=1&name=zhangsan
            var querystring = url.indexOf('?') == -1 ? '?' : '&';
            for (var key in data) {
                querystring += key + '=' + data[key] + '&';
                //            id=          1   &
            }
            //querystring=?id=1&name=zhangsan&
            //3 处理url地址中的回调参数
            //url+=callback=sdfsfdg

            querystring += 'callback=' + cbFuncName;
            //querystring=?id=1&name=zhangsan&cb=my_json_cb_0231241
            //4 创建一个script的标签
            var scriptElement = document.createElement('script');
            scriptElement.src = url + querystring;
            // 此时还不能将其append到页面上

            //5 将script标签放到页面中
            document.body.appendChild(scriptElement);
            //append过后页面会自动对这个地址发送请求，请求完成以后自动执行脚本

        };

        /*把jsonp放到全局*/
        window.$jsonp = jsonp;

    })(window, document);
    ```

